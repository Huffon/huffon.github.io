---
layout: post
title: "Learn Flutter & Dart Sec.4: Day-6"
subtitle: 'Udemy 강좌: Learn Flutter & Dart to build iOS & Android Apps 정리하기'
author: "devfon"
header-style: text
lang: kr
tags:
  - Flutter
  - Mobile
---

_본 시리즈는 Udemy의 강좌 [**Learn Flutter & Dart to build iOS & Android Apps**](https://www.udemy.com/course/learn-flutter-dart-to-build-ios-android-apps/)를 수강하며 중요한 개념들을 정리하고자 작성되었습니다._

# An Overview of the Core Flutter Widgets

![](/img/in-post/miw.png)

- MaterialApp은 안드로이드 스타일의 어플리케이션을, CupertinoApp은 iOS 스타일의 어플리케이션을 제작하기 위한 Widget
- Scaffold / CupertinoPageScaffold는 default로 하얀색 바탕화면을 주는 Widget으로 AppBar 등의 레이아웃을 추가할 수 있는 페이지 단위의 Widget
- Container Widget은 Styling, Alignment 등 다양한 옵션을 제공해주는 레이아웃
	- 주로 Styling, Alignment 등의 옵션을 특정 Widget에 부여해주기 위한 Wrapper Widget으로 사용됨
- Row / Column은 Container와 달리 Multiple children Widgets를 인자로 받을 수 있으며, 각각 Widget들을 좌에서 우로 혹은 위에서 아래로 배열해주기 위한 Layout Widget
	- Row와 Column 안에 또 다른 Row, Column을 child로 넣어서 사용할 수도 있음
- Flexible과 Expanded는 해당 Layout Widget이 감싼 children들이 각각 얼만큼의 공간을 차지할지를 결정하기 위해 사용되는 Widget으로 두 Widget 모두 Row와 Column Widget에서 사용이 가능

![](/img/in-post/miw2.png)

- Stack Widget은 children들을 위 그림과 같이 위아래로 쌓을 때 효과적인 Widget
- Card Widget은 현대 어플리케이션들에서 많이 볼 수 있는 형태의 Card item 제작을 위한 Layout Widget

![](/img/in-post/miw3.png)

- ListView는 스크롤 할 수 있는 Column Widget
- GridView는 Column과 Row가 섞인 형태로 아이템을 배열해주는 Widget으로, 역시 스크롤이 가능한 Widget
- ListTile은 ListView의 각 아이템에 적용 가능한 Container Widget

![](/img/in-post/miw4.png)

- 사용자의 입력 값을 받을 수 있는 Widget들로는 TextField, 각종 버튼, GestureDetectore, InkWell 등이 있음
- 이 중, InkWell은 사용자의 클릭과 관련한 효과를 지니는 Widget

<br/>

# Combining Widgets

- 새로운 프로젝트에서 URI 제대로 찾지 못할 때 `flutter packages get` 명령어를 통해 Flutter 패키지를 다시 로드해주자 !
- Card는 Parent 혹은 Child의 크기에 따라 크기가 조정되며, Card Widget의 크기를 조정하기 위해서는 부모 혹은 자식 Widget의 크기를 조정해주어야 함
	- Text를 Container로 감싸주거나,
	- Card를 Container로 감싸주어 해당 문제를 해결할 수 있음

```dart
// 1번 예시
Card(
  color: Colors.blue,
  child: Container(
    width: double.infinity,
    child: Text('Chart'),
  ),
  elevation: 5,
)

// 2번 예시
Container(
  width: double.infinity,
  child: Card(
    color: Colors.blue,
    child: Text('Chart'),
    elevation: 5,
  ),
)
```

- 위 예제를 통해 Card Widget은 Parent/Child의 크기에 영향을 받는 것을 알 수 있음
- Column은 height는 Viewport의 최대를 받지만 Width의 경우, children이 필요한 만큼만 할당
	- 따라서 Container를 사용해 width를 Viewport의 최대로 설정하게 되면 해당 Container로 인해 Column의 width 역시 Viewport의 최대 값으로 변경
- 보다 정확히 이야기하면 Card Widget은 Child Widget의 크기에 따라 크기가 조정되지만, Parent Widget의 크기가 명시되어 있다면 Parent Widget의 크기를 따라 감
- 우리가 하고자 하는 설정을 Flutter에서는 하나 이상의 방법을 통해 수행할 수 있기 때문에 여러 실험을 통해 배우는 것이 가장 중요

<br/>

# Understanding Column Alignment

![](/img/in-post/candr.png)

- crossAxisAlignment와 mainAxisAlignment는 Column Widget의 핵심 설정 값
- Column Widget에서 `mainAxisAlignment`를 `MainAxisAlignment.end`로 설정하면, 화면 가장 하단에 children들이 위치하게 됨
	- `spaceBetween` 옵션은 children 사이의 공간을 Column Widget이 모두 가져감
	- `spaceAround` 옵션은 여유 공간의 절반을 첫 번째와 마지막 child 앞 뒤에 분배
	- `spaceEvenly` 옵션은 childern들 사이의 공간을 모두 균등하게 분배
- Column Widget에서 `crossAxisAlignment`를 `CrossAxisAlignment.start`로 설정하면 children들이 좌측에 위치하게 됨
	- `stretch` 옵션은 children들이 가질 수 있는 width를 다 가지도록 하는 옵션

<br/>

# Not a Widget: Adding a Transaction Model & Transaction Data

- 소비 내역을 담는 Transaction의 경우, Widget이 아닌 Dart class로 정의
- 해당 Class에 담긴 값들은 객체 생성 이후 변하지 않아야 하므로, 모든 멤버 변수는 `final`로 정의
- `@required` decorator는 `material.dart` 뿐만 아니라 `foundation.dart`에도 있기 때문에 `foundation.dart` 패키지를 임포트 !

```dart
import 'package:flutter/foundation.dart';

class Transaction {
  final String id;
  final String title;
  final double amount;
  final DateTime date;

  Transaction({
    @required this.id,
    @required this.title,
    @required this.amount,
    @required this.date,
  });
}
```

<br/>

# Mapping Data Into Widgets

```dart
Column(
  children: transactions.map((tx) {
    return Card(
      child: Text(tx.title),
    );
  }).toList(),
)
```

- Transaction이 몇 개 있는지 알 때는 Card Widget을 하드 코딩 할 수 있지만, 갯수를 모를 경우 하드 코딩이 불가능
	- 개발자는 환경에 맞춰 유연하게 Widget이 생성되도록 코드를 작성해야 함
	- 하드 코딩으로 로직을 처리하려는 습관을 지양하자 !
- Dynamic하게 List를 List of Widget으로 변경해주기 위해서는 역시 **map()** 메서드를 사용 !
	- `map()` 메서드는 Iterable을 반환하기 때문에 항상 `toList()` 메서드를 호출시켜주자

<br/>

# Building a Custom List item

![](/img/in-post/card.png)

- 각각의 Transaction은 위 그림과 같은 Card Widget으로 구성될 수 있음

```dart
return Card(
  child: Row(
    children: <Widget>[
      Container(
        child: Text(
          tx.amount.toString(),
        ),
      ),
      Column(
        children: <Widget>[
          Text(tx.title),
          Text(
            tx.date.toString(),
          ),
        ],
      ),
    ],
  ),
);
```

<br/>

# Styling a Container and Text + More Styling !

- Flutter에서는 CSS 같은 추가적인 코드 작성을 통해 스타일링을 하지 않고, Widget에 전달하는 argument를 활용해 스타일링을 적용할 수 있음
- 만약 특정 Widget에 원하는 스타일링을 적용할 수 없을 경우 해당 Widget을 Wrapping한 후, Wrapper Widget에 스타일링을 적용해 문제를 해결할 수 있음
	- e.g.) `Row` Widget에서는 **decoration** 옵션이 없지만 `Container` Widget에는 해당 옵션이 존재
- `EdgeInsets.symmetric` 옵션은 Edge를 **horizontal** 혹은 **vertical**하게 부여할 수 있게 도와줌
- `decoration`에 `BoxDecoration` 스타일 클래스를 사용할 수 있음
	- `border` 인자에 `BoxBorder`, `Border` 등의 클래스 인자를 사용 가능
	- `Border`의 경우 `Border.all`라는 Extra Contstructor를 사용해 효과적으로 border 옵션을 적용할 수 있음

```dart
Container(
  margin:
    EdgeInsets.symmetric(vertical: 10, horizontal: 15),
  child: Text(
    tx.amount.toString(),
  ),
  decoration: BoxDecoration(
    border: Border.all(
      color: Colors.black,
      width: 2,
    ),
  ),
  padding: EdgeInsets.all(10),
)
``` 

- Text Widget도 마찬가지로 `Container`에 의해 스타일링 될 수 있지만, Text 자체의 argument를 활용해 스타일링 할 수도 있음
- Container 역시 자신이 감싸고 있는 child widget의 크기에 의해 크기가 변함

```dart
child: Text(
  tx.amount.toString(),
  style: TextStyle(
    fontWeight: FontWeight.bold,
    fontSize: 20,
  ),
)


---
layout: post
title: "Learn Flutter & Dart: Day-2"
subtitle: 'Udemy 강좌: Learn Flutter & Dart to build iOS & Android Apps 정리하기'
author: "devfon"
header-style: text
lang: kr
tags:
  - Flutter
  - Mobile
---

_본 시리즈는 Udemy의 강좌 [**Learn Flutter & Dart to build iOS & Android Apps**](https://www.udemy.com/course/learn-flutter-dart-to-build-ios-android-apps/)를 수강하며 중요한 개념들을 정리하고자 작성되었습니다._

# Flutter Basics
## Project Structure
- Directory
	- `idea`: Android Studio의 설정 값
	- `android/ios`: Flutter SDK를 이용해 Flutter Code-base를 Compile 시, 변환될 Android/iOS 프로젝트 디렉토리
		- 거의 수정할 일이 없으며, 아주 가끔 수정할 일이 생길 수 있음
		- Flutter가 사용하는 **Passive** 폴더라고 생각하자!
	- `build`: Flutter application의 산출물이 저장되는 폴더
		- Android, Java, .. 파일들이 저장됨
		- 해당 폴더 역시 Flutter에 의해 생성되고 관리되는 **Passive** 폴더
	- `lib`: 우리가 작업을 가장 많이 수행하게 될 폴더로, 새로이 추가하는 **Dart** 파일을 모두 이곳에 저장
	- `test`: Automated test를 위한 Test 코드를 작성하는 폴더
- File
	- `metadata`: Flutter가 관리하는 파일로, build에 필요한 정보들이 저장됨
	- `packages`: Flutter SDK가 관리하는 파일로 내부 의존성 관리를 위한 **Package** 정보가 저장됨
	- `APP_NAME.iml`: Flutter SDK가 관리하는 파일로 의존성 관리를 위한 Package 정보와 각종 설정 값이 저장됨
	- `pubspec.yaml`: 우리가 작업해야 하는 파일로 Application에서 사용되는 Font, Images, Third-party packages' 의존성 정보 등을 기록하는 파일
	- `pubspec.lock`: `pubspec.yaml` 파일에 기록된 정보를 기반으로 생성되는 파일로, yaml 파일에 기록된 정보들의 보다 상세한 정보들이 기록됨 
<br/>

## main.dart 코드 분석
- Flutter는 Framework이자 Tool-set
- Flutter Application은 Widget을 이용해 UI를 구성한 Application
![](/img/in-post/flutter-screen.jpg)
```
Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            Text(
              'You have pushed the button this many times:',
            ),
            Text(
              '$_counter',
              style: Theme.of(context).textTheme.display1,
            ),
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _incrementCounter,
        tooltip: 'Increment',
        child: Icon(Icons.add),
      ), // This trailing comma makes auto-formatting nicer for build methods.
    );
  }
```
- 위 코드에서 사용된 `Text`, `FloatingActionButton` 등은 Flutter framework에서 기본적으로 제공해주는 컴포넌트
- 이뿐만 아니라 다양한 Button, Drop-down, Image, List 등의 컴포넌트들을 사용할 수 있음
- 따라서 우리는 해당 Widget들을 활용해 UI를 구성할 수 있음
	- `style: Theme.of(context).textTheme.display1` 등의 코드를 통해 Widget의 설정 값 또한 변경 가능
- 기정의된 컴포넌트들을 활용해 Customized Widget도 직접 생성할 수 있음
<br/>

## Building an App From Scracth
![](/img/in-post/flutter-widget\.png)
- Flutter는 모든 것이 Widget으로 표현되기 때문에, Widget이 또 다른 Widget를 품을 수 있음
- 때문에 Root Widget이 되는 것은 Mobile Application 그 자체이며, Application의 각 Page는 Scaffold라는 단위의 Page Widget이 됨
- `pubspec.yaml` 파일에 Flutter SDK dependency가 설정되어 있기 때문에, Flutter가 제공하는 기본 객체들을 사용 가능 (w. `extends` 키워드)
```
import 'package:flutter/material.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(home: Text('Hello!'),);
  }
}
```
- `package:flutter/material.dart` 패키지에 Material Design이 적용된 다양한 컴포넌트들이 존재함
	- `StatelessWidget`은 해당 패키지에 위치한 Base class 중 하나
	- Flutter의 모든 Widget들은 `StatelessWidget` 혹은 `StatefulWidget` 중 하나의 Base class를 상속 받음
- `build` 함수는 Flutter가 Widget을 화면에 그리기 위해 호출하는 함수이기 때문에 `Widget`을 반환해야 함
- `MaterialApp`은 내가 사용하는 Widget들이 화면에 올바르게 Rendering 될 수 있게 도와주는 Widget
	- `home` 인자는 Application이 화면에 이식될 때 Flutter가 그려주는 Core Widget
- `runApp()` 함수는 우리가 생성한 Widget들을 화면에 그리기 위해 각 Widget의 `build` 함수를 호출
- Flutter를 사용하면 우리는 UI에만 신경쓰면 Rendering도 해주고, Life-cycle도 크게 신경쓰지 않아도 된다는 장점
- `@override` decorator를 붙여주지 않아도 상기 코드는 작동하지만, MyApp이 상속 받는 StatelessWidget에 기정의된 `build` 메서드를 의도적으로 Over-write 한다는 점을 명시하기 위해 `@override` decorator를 반드시 붙여주는 습관을 들이자  
- 상기 코드 중 main() 함수는 `void main() => runApp(MyApp());`와 같이 short-hand 코딩이 가능
	- 만약 함수가 단 한 줄의 표현만을 필요로 한다면 `=>` 문법을 활용해 위와 같은 short-hand 코딩을 사용하자
<br/>

# Dart Basics
- Dart는 Type Language이기 때문에 Type을 반드시 가짐
	- Dynamic Type을 허용하긴 하지만, 특별한 일이 아니라면 반드시 Type을 명시해주자
- main()은 특별한 함수로, Dart application의 Entry point가 되는 함수
	- Flutter에서는 `main.dart`가 Entry point로 사용되는 파일이 되어줌
- Dart는 Camel case를 따르기 때문에 변수명 선정에 주의하자
- `num` 자료형은 `int`와 `double` 타입의 변수를 모두 포괄하는 타입
	- `double` 자료형 역시 `int`를 `double`로 변환해 받을 수 있기 때문에 `num`과 동일한 기능
- 문자열 자료형을 나타내는 `String`은 대문자 `S`로 시작함에 주의
- Dart는 Type Inference 기능을 내장하고 있기 때문에 할당하는 값의 타입을 유추해 `var` 타입의 변수의 타입 유추 가능
	- 그러나, `var` 자료형을 남발하는 것보다 실제 사용되는 자료형을 사용하는 연습을 하는 것이 바람직함
- Dart에서 모든 것은 객체: Object-Oriented Programming Language
- 객체는 Pascal Convetion을 따라 이름을 지어야 함: e.g.) `MyApp`, `KoreanPerson`, ...

<br/>

## Class Constructors & Named Arguments
- Class를 보다 Generic하게 사용하기 위해 Constructor가 필요함
	- Constructor는 최초 객체 생성 시 단 한 번만 실행되는 메서드
```
class Person {
	String name;
	int age;

	// 평범한 Constructor
	// Person(String name, int age) {
	//   this.name = name;
	//   this.age = age;
	// }

	// Syntactic sugar를 적용한 Constructor
	Person(this.name, this.age);
}

void main() {
	var p1 = Person('Max', 30);
	var p2 = Person('Manu', 31);
}
```
- Named Argument: 인자를 Optional하게 받기 때문에 함수 호출 시, 어떠한 인자에 대한 값인지 특별히 명시를 해주어야 함
	- 처리해야 할 인자가 많은 경우 Non-name argument를 사용하면 인자의 등장 위치를 모두 기억해야 하는 불편함이 있음
	- 따라서 인자를 많이 처리하는 함수에는 Named Argument를 적용하는 것이 바람직함
- Named Argument에는 Default value를 부여해줄 수 있음
```
class Person {
	String name;
	int age;

	Person({this.name, this.age = 30});
}

void main() {
	var p1 = Person(name: 'Max');
	print(p1.age);  // 30
}
```
- Flutter에서는 `@required` 어노테이션을 Named Argument에 붙여, Optional이 아닌 required 인자로 만들어줄 수 있음
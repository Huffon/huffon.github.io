---
layout: post
title: "Learn Flutter & Dart: Day-2"
subtitle: 'Udemy 강좌: Learn Flutter & Dart to build iOS & Android Apps 정리하기'
author: "devfon"
header-style: text
lang: kr
tags:
  - Flutter
  - Mobile
---

_본 시리즈는 Udemy의 강좌 [**Learn Flutter & Dart to build iOS & Android Apps**](https://www.udemy.com/course/learn-flutter-dart-to-build-ios-android-apps/)를 수강하며 중요한 개념들을 정리하고자 작성되었습니다._

# Flutter Basics
## Project Structure
- Directory
	- `android/ios`: **Flutter SDK**를 이용해 Flutter 코드 베이스를 Compile 시, 변환되는 Android/iOS 프로젝트의 디렉토리
		- 우리가 수정할 일은 거의 없지만, 아주 가끔 수정할 일이 생길 수 있음
		- Flutter가 사용하는 **Passive** 폴더라고 생각하자!
	- `build`: **Flutter application**의 산출물들이 저장되는 폴더
		- Android, Java, .. 등의 파일들이 저장
		- 해당 폴더 역시 Flutter에 의해 생성되고 관리되는 **Passive** 폴더
	- `lib`: **우리가 작업을 가장 많이 수행하게 될 폴더**로, 새로이 작성하는 **Dart** 파일을 모두 이곳에 저장함
	- `test`: Application 빌드 시, Automated test를 위한 Test 코드 작성하는 폴더
- File
	- `metadata`: Flutter가 관리하는 파일로, 어플리케이션 빌드에 필요한 정보들을 저장
	- `packages`: Flutter SDK가 관리하는 파일로 **내부 의존성 관리**를 위한 **Package**들의 정보를 저장됨
	- `APP_NAME.iml`: Flutter SDK가 관리하는 파일로 의존성 관리를 위한 Package 정보와 각종 설정 값을 저장
	- `pubspec.yaml`: **우리가 작업해야 하는 파일**로 어플리케이션에서 사용되는 **Font, Images, Third-party packages' 의존성 정보** 등 기록하는 YAML 파일
	- `pubspec.lock`: `pubspec.yaml` 파일에 기록된 정보를 기반으로 생성되는 파일로, yaml 파일에 기록된 정보들의 보다 상세한 정보들이 기록되는 파일
- 우리가 가장 많이 사용할 폴더 및 파일은 `lib` 폴더와 `pubspec.yaml` 파일 !

<br/>

## main.dart 코드 분석
- Flutter Application은 Widget을 이용해 화면 UI를 구성하는 Application
![](/img/in-post/flutter-screen.jpg)
```
Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            Text(
              'You have pushed the button this many times:',
            ),
            Text(
              '$_counter',
              style: Theme.of(context).textTheme.display1,
            ),
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _incrementCounter,
        tooltip: 'Increment',
        child: Icon(Icons.add),
      ), // This trailing comma makes auto-formatting nicer for build methods.
    );
  }
```
- 위 코드에서 사용된 `Text`, `FloatingActionButton` 등은 **Flutter framework**에서 기본적으로 제공해주는 컴포넌트
- 이뿐만 아니라 **Button, Drop-down, Image, List** 등 다양한 컴포넌트를 사용할 수 있음
- 우리는 해당 Widget들을 활용해 Application UI를 구성할 수 있음
	- `style: Theme.of(context).textTheme.display1` 등의 코드를 통해 Widget의 설정 값 또한 변경 가능
- +) 기정의된 컴포넌트들을 활용해 **Customized Widget**도 직접 구성할 수 있음

<br/>

## Building an App From Scracth
![](/img/in-post/flutter-widget\.png)
- Flutter는 **모든 것이 Widget**으로 표현되기 때문에, Widget은 또 다른 Widget을 가질 수 있음
	- 때문에 **Root Widget**이 되는 것은 **Application 그 자체**이며, Application의 각 Page는 **Scaffold라는 단위의 Page Widget**
- 앞서 살펴본 `pubspec.yaml` 파일에 **Flutter SDK dependency**가 기설정되어 있기 때문에, Flutter가 제공하는 기본 객체들 사용 가능 (with. `extends` 키워드)

```
import 'package:flutter/material.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(home: Text('Hello!'),);
  }
}
```

- `package:flutter/material.dart` 패키지에는 Google의 Material Design이 적용된 다양한 컴포넌트가 존재
	- 상기 코드에서 사용된 `StatelessWidget`은 `material.dart` 패키지에 존재하는 **Base class**
	- Flutter의 모든 Widget들은 `StatelessWidget` 혹은 `StatefulWidget` 중 하나의 **Base class**를 상속 받아야 함
- `build` 함수는 Flutter가 **Widget을 화면에 그리기 위해 호출하는 함수**이기 때문에 반드시 `Widget`을 반환해야 함
- `MaterialApp`은 우리가 사용하는 Widget들이 화면에 올바르게 **Rendering** 될 수 있게 도와주는 Widget
	- `home` 인자에는 Application이 화면에 이식될 때, **Core Widget**으로 사용되는 Widget이 넘겨진다.
- `runApp()` 함수는 우리가 생성한 Widget들을 화면에 그리기 위해 각 Widget들의 `build` 함수 호출
- `@override` decorator를 붙이지 않아도 상기 코드는 작동하지만, MyApp이 상속 받는 `StatelessWidget`에 기정의된 `build` 메서드를 **의도적으로 Over-write** 한다는 점을 명시해주기 위해 `@override` decorator를 붙여주는 습관을 들여야 함  
- 상기 코드 중 main() 함수 블록은 `void main() => runApp(MyApp());`와 같이 **short-hand 코딩**으로 대체 가능
	- 만약 함수가 **단 한 줄의 표현**만을 사용한다면 `=>` 문법을 활용해 위와 같은 short-hand 코딩으로 대체하자
- 이처럼 Flutter를 사용하게 되면 우리는 **UI**에만 신경쓰면 되게 됨
	- Flutter가 Widget들을 직접 화면에 Rendering 해주고, 
	- Life-cycle도 관리해줌

<br/>

# Dart Basics
- Dart는 **Type Language**이기 때문에 모든 변수는 Type을 가짐
	- **Dynamic Type**을 허용하긴 하지만, 특별한 일이 아니라면 반드시 Type을 명시해주자
- `main()`은 **특별한 함수**로, Dart application의 **Entry point**가 되어주는 함수
	- _cf) Flutter에서는 `main.dart`가 **Entry point** 파일_
- Dart는 **Camel case**를 따르기 때문에 변수명 선정에 주의: e.g.) `getAge()`, `getName()`, ...
- `num` 자료형은 `int`와 `double` 타입 변수를 모두 포괄하는 타입
	- `double` 자료형 역시 `int`를 `double`로 변환해 받기 때문에 `num`과 동일한 기능 수행
- 문자열 자료형은 `String` 타입으로 선언해주어야 함
- Dart는 **Type Inference** 기능을 내장하고 있기 때문에, **할당 값의 타입을 유추**해 `var` 타입의 변수도 타입 추론 가능
	- 그러나, `var` 자료형을 남발하는 것보다 실제 사용되는 자료형을 명시적으로 사용하는 연습을 하는 것이 바람직
- Dart에서 **모든 것은 객체**: Object-Oriented Programming Language
- 객체는 **Pascal Convetion**을 따라 이름을 지어주어야 함: e.g.) `MyApp`, `KoreanPerson`, ...

<br/>

## Class Constructors & Named Arguments
- Class를 **보다 Generic하게 사용**하기 위해 **Constructor**가 필요
	- **Constructor**는 객체 생성 시 **최초 1회**만 실행되는 메서드

```
class Person {
	String name;
	int age;

	// 평범한 Constructor
	// Person(String name, int age) {
	//   this.name = name;
	//   this.age = age;
	// }

	// Syntactic sugar를 적용한 Constructor
	Person(this.name, this.age);
}

void main() {
	var p1 = Person('Max', 30);
	var p2 = Person('Manu', 31);
}
```

- **Named Argument**: 인자를 **Optional**하게 받기 때문에 함수 호출 시, 어떠한 인자에 대한 값인지 반드시 명시를 해주어야 함
	- 처리해야 할 인자가 많은 경우 Non-named argument를 사용하면 인자의 순서를 모두 기억해야 하는 불편함
		- 첫 번째 인자는 integer 자료형의 A, 두 번째 인자는 String 자료형의 B, ... : 모두 기억하기 어렵다 !
	- 따라서 많은 인자를 처리하는 함수에는 **Named Argument**를 적용하는 것이 매우 바람직
- +) Named Argument에는 다음과 같이 **Default value**를 부여해줄 수도 있음

```
class Person {
	String name;
	int age;

	Person({@required this.name, this.age = 30});
}

void main() {
	var p1 = Person(name: 'Max');
	print(p1.age);  // 30
}
```

- Flutter에서는 `@required` 어노테이션을 제공하는데 이는 Named Argument에 사용할 수 있는 어노테이션으로, 해당 인자를 **Optional**이 아닌 **Required** 인자로 취급하겠다는 의미
